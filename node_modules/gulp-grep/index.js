"use strict";
var PLUGIN_NAME, console, gutil, log4js, minimatch, through, _, _splitPositivesNegatives;

gutil = require("gulp-util");

through = require("through2");

minimatch = require("minimatch");

_ = require("lodash");

log4js = require('log4js');

log4js.configure("" + __dirname + "/log4js.config.json", {});

console = log4js.getLogger();

PLUGIN_NAME = "gulp-grep";

_splitPositivesNegatives = function(arr) {
  var neg, pos;
  pos = _.filter(arr, function(el) {
    return /^(?!\!).*/.test(el);
  });
  neg = _.filter(arr, function(el) {
    return /^(?=\!).*/.test(el);
  });
  return {
    positives: pos,
    negatives: neg
  };
};

module.exports = function(pat, opt) {
  var filteredOutStream, minimatchOpt, options, patterns, splitPatterns, stream, _flush, _match, _transform;
  options = opt || {};
  patterns = pat || {};
  if (options.debug) {
    console.setLevel('DEBUG');
  }
  console.debug("[gulp.grep()]");
  console.debug("  arg `patterns`: ", patterns);
  console.debug("  arg `options`: ", options);
  minimatchOpt = _.omit(options, ['debug', 'restorable']);
  console.debug("  minimatch options object:", minimatchOpt);
  console.debug("  validating params...");
  if ((["string", "function"].indexOf(typeof pat) === -1) && !Array.isArray(pat)) {
    throw new gutil.PluginError(PLUGIN_NAME, "`patterns` should be an array, string, or a function");
  }
  console.debug("  normalizing params...");
  if (typeof patterns === "string") {
    patterns = [patterns];
  }
  splitPatterns = _splitPositivesNegatives(patterns);
  console.debug("  splitPatterns", splitPatterns);
  if (options.restorable) {
    filteredOutStream = through.obj();
  }
  _transform = function(file, enc, cb) {
    console.debug("[_transform()]");
    if (_match(file)) {
      console.debug("  match found: " + file.path);
      this.push(file);
      return cb();
    }
    if (options.restorable) {
      console.debug("  writing " + file.path + " to filteredOutStream");
      filteredOutStream.write(file);
    }
    cb();
  };
  _flush = function(cb) {
    console.debug("[_flush()]");
    filteredOutStream && filteredOutStream.end();
    cb();
  };
  _match = function(file) {
    var pattern, result, _fn, _fn1, _i, _j, _len, _len1, _ref, _ref1;
    console.debug("[_match()]");
    console.debug("  file: " + file);
    result = void 0;
    switch (typeof patterns) {
      case "function":
        result = patterns(file);
        break;
      default:
        console.debug("  positives: " + splitPatterns.positives);
        console.debug("  negatives: " + splitPatterns.negatives);
        _ref = splitPatterns.positives;
        _fn = function(pattern) {
          return result = result || minimatch(file.path, pattern, minimatchOpt);
        };
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          pattern = _ref[_i];
          _fn(pattern);
          if (result) {
            break;
          }
        }
        _ref1 = splitPatterns.negatives;
        _fn1 = function(pattern) {
          return result = result && minimatch(file.path, pattern, minimatchOpt);
        };
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          pattern = _ref1[_j];
          _fn1(pattern);
          if (!result) {
            break;
          }
        }
    }
    console.debug(" match?: " + result);
    return result;
  };
  stream = through.obj(_transform, _flush);
  stream.restoreFilteredOut = function() {
    console.debug("[restoreFilteredOut()]");
    options.restorable || (function() {
      throw new gutil.PluginError(PLUGIN_NAME, "cannot call restoreFilteredOut() on a non-restorable stream. Create stream with { restorable: true } first.");
    })();
    return filteredOutStream;
  };
  return stream;
};
