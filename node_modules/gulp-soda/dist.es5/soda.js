'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

// native imports
var path = require('path');

/**
* defaults:
**/

// regex to filer which plugins to laod
var R_PLUGINS = /^(gulp|vinyl)\-/;

// transform plugin name to hash key
var F_TRANSFORM = function F_TRANSFORM(s_dep) {

	// strip first word from plugin name
	return s_dep.replace(/^(\w+)\-(.+)$/, '$2')

	// replace hyphens with underscore
	.replace(/\-/g, '_');
};

// directory relative from root where...
var S_SRC_DIR = 'lib'; //...source files are
var S_DEST_DIR = 'dist'; //...build output goes
var S_RECIPE_DIR = 'gulp'; //...gulp task recipes are

//
var error = function error(s_msg) {
	var e_error = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

	if (!e_error) {
		e_error = new Error();
		e_error.stack = 'Error:\n' + s_msg;
	} else {
		e_error.stack = 'Error:\n' + s_msg + '\n\n' + e_error.stack;
	}
	throw e_error;
};

/**
* main:
**/
module.exports = function (gulp) {
	var h_config = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];


	/**
 * load plugins:
 **/

	// ref gulpfile dir (project root)
	var p_root = path.dirname(module.parent.parent.filename);

	// plugin options
	var h_plugin_options = h_config.plugins || {};

	// ref plugin regex
	var r_plugins = h_plugin_options.pattern || R_PLUGINS;

	// ref plugin transform
	var f_transform = h_plugin_options.transform || F_TRANSFORM;

	// prep plugins hash
	var h_plugins = void 0;

	// prep devDependencies hash
	var h_dev_dependencies = {};

	// load plugins
	var plugins = function plugins() {
		// not yet cached
		if (!h_plugins) {
			// make plugins hash
			h_plugins = {};

			// load module's package.json
			h_dev_dependencies = require(path.join(p_root, 'package.json')).devDependencies;

			// fetch dev dependencies from package.json
			Object.keys(h_dev_dependencies)
			// each gulp plugin (or whatever matches the regex)
			.forEach(function (s_dep) {

				// found gulp plugin
				if (r_plugins.test(s_dep)) {

					// skip loading this package
					if ('gulp-soda' === s_dep) return;

					// make npm require path to plugin
					var p_plugin = path.join(p_root, 'node_modules', s_dep);

					// transform name to key, load plugin into hash
					h_plugins[f_transform(s_dep)] = require(p_plugin);
				}
			});
		}

		return h_plugins;
	};

	/**
 * load recipes:
 **/

	// ref recipe dir
	var s_recipe_dir = h_config.recipes || S_RECIPE_DIR;

	// ref recipe directory
	var p_recipe_dir = path.join(p_root, s_recipe_dir);

	/**
 * make tasks:
 **/

	// prep task info hash
	var h_task_info = {};

	// ref global config
	var h_global_config = h_config.config || {};

	// ref domain & range
	var h_domain = h_config.domain || {};
	var h_range = h_config.range || {};

	// ref src and dest root
	var s_src_dir = h_config.src || S_SRC_DIR;
	var s_dest_dir = h_config.dest || S_DEST_DIR;

	// ref options
	var h_options = h_config.options || {};

	// prep task lists hash
	var h_task_lists = {};

	// track empty task dependencies
	var h_empty_tasks = {};

	// each dir target in domain

	var _loop = function _loop(s_dir) {

		// ref range
		var a_range = h_domain[s_dir];

		// assure range is array
		if ('string' === typeof a_range) a_range = [a_range];

		// prep list of defaults for directory task list
		var a_defaults = [];

		// prep groups hash for gourping same names of different outputs
		var h_groups = {};

		// each range in array
		a_range.forEach(function (s_range_target) {

			// extract labels from range target

			var _s_range_target$split = s_range_target.split(/\s*[:\s]\s*/);

			var _s_range_target$split2 = _slicedToArray(_s_range_target$split, 2);

			var s_range = _s_range_target$split2[0];
			var s_task_dest_dir = _s_range_target$split2[1];

			// ref recipe list

			var a_recipe_list = h_range[s_range];

			// create src and dest paths
			var p_src = path.join(s_src_dir, s_dir);
			var p_dest = path.join(s_task_dest_dir || s_dest_dir, s_dir);

			// each recipe
			a_recipe_list.forEach(function (s_recipe_target, i_recipe) {

				// extract recipe name and its dependencies from target string

				var _s_recipe_target$spli = s_recipe_target.split(/\s*[:\s]\s*/g);

				var _s_recipe_target$spli2 = _toArray(_s_recipe_target$spli);

				var s_recipe = _s_recipe_target$spli2[0];

				var a_deps = _s_recipe_target$spli2.slice(1);

				// task is empty (no recipe)


				var b_empty_task = '[' === s_recipe[0];
				if (b_empty_task) {
					s_recipe = s_recipe.slice(1, -1);
				}

				// make task name
				var s_task = s_recipe + '-' + s_dir;

				// ref task name mod
				var s_task_mod = '';

				// there are multiple ranges
				if (a_range.length > 1) {
					//	shift task name to group name
					var s_group = s_task;

					// ref group
					var a_group = h_groups[s_group] || (h_groups[s_group] = []);

					// create distinguished task name
					s_task_mod = '-' + s_range;
					s_task += s_task_mod;

					// add this task name to the group
					a_group.push(s_task);
				}

				// this recipe is 0th target in domain, add it to the defaults
				if (0 === i_recipe) {
					a_defaults.push(s_task);
				}

				// make dpes for this task
				var a_task_deps = a_deps.map(function (s_dep) {
					return s_dep + '-' + s_dir + s_task_mod;
				});
				a_task_deps.forEach(function (s_other_task, i_other_task) {
					// ref empty task's dependencies if exists
					var a_empty_deps = h_empty_tasks[s_other_task];

					// it actually is an empty task
					if (a_empty_deps) {
						// append all its dependencies to this list
						a_task_deps.push.apply(a_task_deps, _toConsumableArray(a_empty_deps));

						// remove dependency to empty task
						a_task_deps.splice(i_other_task, 1);
					}
				});

				// make options hash for this task, save to persistent options hash
				var h_task_options = Object.assign({}, h_options['*'] || {}, h_options[s_recipe] || {}, h_options[s_task] || {});

				// make src glob
				var p_task_src = path.join(p_src, h_task_options.src || '');

				// save to task info
				h_task_info[s_task] = {
					src: p_task_src,
					dest: p_dest,
					deps: a_task_deps,
					options: h_task_options
				};

				// dependencies-only recipe; make task
				if (b_empty_task) {
					h_empty_tasks[s_task] = a_task_deps;
					return gulp.task(s_task, a_task_deps);
				}

				// make task, such that only once it is called do we make moves
				gulp.task(s_task, a_task_deps, function (f_done_task) {

					// only once this task is called, load the recipe script
					var f_recipe = void 0;
					try {
						f_recipe = require(path.join(p_recipe_dir, s_recipe) + '.js');
					} catch (e_load_recipe) {
						if ('MODULE_NOT_FOUND' === e_load_recipe.code) {
							error('no such recipe "' + s_recipe + '" found in recipe directory "' + s_recipe_dir + '" {' + (path.join(p_recipe_dir, s_recipe) + '.js') + '}');
						} else {
							error('script recipe "' + s_recipe + '" has a syntax/runtime error:', e_load_recipe);
						}
					}

					// recipe is kind enough to require plugins
					if (f_recipe.plugins) {
						// make plugins hash
						plugins();

						// check each plugin
						f_recipe.plugins.forEach(function (s_plugin) {
							// plugin is missing from devDependencies
							if (!h_dev_dependencies[s_plugin]) {
								console.error('\nWARNING: the "' + s_recipe + '" recipe was kind enough to declare that it requires the "' + s_plugin + '" plugin to function properly; you currently do NOT have such a plugin listed in your package.json\'s devDependencies. This could be the reason for any errors you are getting\n');
							}
						});
					}

					// forward control to recipe
					var z_return = f_recipe.apply({
						// source directory
						src_dir: p_src,

						// set sub directory destination within destination dir
						sub_dest: function sub_dest(s_sub_dir) {
							return path.join(s_task_dest_dir || s_dest_dir, s_sub_dir);
						},

						// config settings
						config: h_global_config,

						// task name
						task: s_task,

						// task dependencies
						deps: a_task_deps,

						// task options
						options: h_task_options,

						// allow recipe to ref other dependencies
						other: function other(s_dep) {
							return s_dep + '-' + s_dir + s_task_mod;
						},

						// allow recipe to ref other src
						friend: function friend(s_dep) {
							return h_task_info[s_dep];
						}
					}, [gulp, plugins(), p_task_src, p_dest, f_done_task]);

					// recipe did not ask for async callback
					if (!z_return && f_recipe.length <= 4) {
						// callback on next event loop pass
						setImmediate(function () {
							f_done_task();
						});
					}

					// return whatever recipe did
					return z_return;
				});

				// ref corresponding task list
				var a_task_list = h_task_lists[s_recipe];

				// corresponding task list does not yet exist; create it
				if (!a_task_list) a_task_list = h_task_lists[s_recipe] = [];

				// append task name to its corresponding task list
				a_task_list.push(s_task);
			});
		});

		// there are multiple outputs
		for (var s_group_name in h_groups) {
			// create task group
			gulp.task(s_group_name, h_groups[s_group_name]);
		}

		// create defaults task group
		gulp.task(s_dir, a_defaults);
	};

	for (var s_dir in h_domain) {
		_loop(s_dir);
	}

	/**
 * append shortcut tasks:
 **/

	// build default tasks for each type
	for (var s_general_task in h_task_lists) {
		var a_deps = h_task_lists[s_general_task];

		// link dependencies to trigger those tasks
		gulp.task(s_general_task, a_deps);
	}

	// ref aliases from config
	var h_aliases = h_config.aliases;

	// add aliases
	Object.keys(h_aliases || {}).forEach(function (s_alias) {
		var a_tasks = h_aliases[s_alias];

		// register alias task
		gulp.task(s_alias, a_tasks);
	});

	// register default task
	gulp.task('default', Object.keys(h_domain));
};
//# sourceMappingURL=data:application/json;base64,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QUZEO0FBR0E7OztBQUdELFlBQU8sUUFBUDtBQUNBLEtBakVEOzs7QUFvRUEsUUFBSSxjQUFjLGFBQWEsUUFBYixDQUFsQjs7O0FBR0EsUUFBRyxDQUFDLFdBQUosRUFBaUIsY0FBYyxhQUFhLFFBQWIsSUFBeUIsRUFBdkM7OztBQUdqQixnQkFBWSxJQUFaLENBQWlCLE1BQWpCO0FBQ0EsSUF6SkQ7QUEwSkEsR0F2S0Q7OztBQTBLQSxPQUFJLElBQUksWUFBUixJQUF3QixRQUF4QixFQUFrQzs7QUFFakMsUUFBSyxJQUFMLENBQVUsWUFBVixFQUF3QixTQUFTLFlBQVQsQ0FBeEI7QUFDQTs7O0FBR0QsT0FBSyxJQUFMLENBQVUsS0FBVixFQUFpQixVQUFqQjtBQWxTMkM7O0FBbUc1QyxNQUFJLElBQUksS0FBUixJQUFpQixRQUFqQixFQUEyQjtBQUFBLFFBQW5CLEtBQW1CO0FBZ00xQjs7Ozs7OztBQVFELE1BQUksSUFBSSxjQUFSLElBQTBCLFlBQTFCLEVBQXdDO0FBQ3ZDLE1BQUksU0FBUyxhQUFhLGNBQWIsQ0FBYjs7O0FBR0EsT0FBSyxJQUFMLENBQVUsY0FBVixFQUEwQixNQUExQjtBQUNBOzs7QUFJRCxLQUFJLFlBQVksU0FBUyxPQUF6Qjs7O0FBR0EsUUFBTyxJQUFQLENBQVksYUFBYSxFQUF6QixFQUE2QixPQUE3QixDQUFxQyxVQUFDLE9BQUQsRUFBYTtBQUNqRCxNQUFJLFVBQVUsVUFBVSxPQUFWLENBQWQ7OztBQUdBLE9BQUssSUFBTCxDQUFVLE9BQVYsRUFBbUIsT0FBbkI7QUFDQSxFQUxEOzs7QUFTQSxNQUFLLElBQUwsQ0FBVSxTQUFWLEVBQXFCLE9BQU8sSUFBUCxDQUFZLFFBQVosQ0FBckI7QUFDQSxDQWpVRCIsImZpbGUiOiJzb2RhLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vLyBuYXRpdmUgaW1wb3J0c1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuLyoqXG4qIGRlZmF1bHRzOlxuKiovXG5cbi8vIHJlZ2V4IHRvIGZpbGVyIHdoaWNoIHBsdWdpbnMgdG8gbGFvZFxuY29uc3QgUl9QTFVHSU5TID0gL14oZ3VscHx2aW55bClcXC0vO1xuXG4vLyB0cmFuc2Zvcm0gcGx1Z2luIG5hbWUgdG8gaGFzaCBrZXlcbmNvbnN0IEZfVFJBTlNGT1JNID0gKHNfZGVwKSA9PiB7XG5cblx0Ly8gc3RyaXAgZmlyc3Qgd29yZCBmcm9tIHBsdWdpbiBuYW1lXG5cdHJldHVybiBzX2RlcC5yZXBsYWNlKC9eKFxcdyspXFwtKC4rKSQvLCAnJDInKVxuXG5cdFx0Ly8gcmVwbGFjZSBoeXBoZW5zIHdpdGggdW5kZXJzY29yZVxuXHRcdC5yZXBsYWNlKC9cXC0vZywgJ18nKTtcbn07XG5cbi8vIGRpcmVjdG9yeSByZWxhdGl2ZSBmcm9tIHJvb3Qgd2hlcmUuLi5cbmNvbnN0IFNfU1JDX0RJUiA9ICdsaWInOyAvLy4uLnNvdXJjZSBmaWxlcyBhcmVcbmNvbnN0IFNfREVTVF9ESVIgPSAnZGlzdCc7IC8vLi4uYnVpbGQgb3V0cHV0IGdvZXNcbmNvbnN0IFNfUkVDSVBFX0RJUiA9ICdndWxwJzsgLy8uLi5ndWxwIHRhc2sgcmVjaXBlcyBhcmVcblxuXG4vL1xuY29uc3QgZXJyb3IgPSAoc19tc2csIGVfZXJyb3I9ZmFsc2UpID0+IHtcblx0aWYoIWVfZXJyb3IpIHtcblx0XHRlX2Vycm9yID0gbmV3IEVycm9yKCk7XG5cdFx0ZV9lcnJvci5zdGFjayA9ICdFcnJvcjpcXG4nK3NfbXNnO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGVfZXJyb3Iuc3RhY2sgPSAnRXJyb3I6XFxuJytzX21zZysnXFxuXFxuJytlX2Vycm9yLnN0YWNrO1xuXHR9XG5cdHRocm93IGVfZXJyb3I7XG59O1xuXG5cbi8qKlxuKiBtYWluOlxuKiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGd1bHAsIGhfY29uZmlnPXt9KSB7XG5cblx0LyoqXG5cdCogbG9hZCBwbHVnaW5zOlxuXHQqKi9cblxuXHQvLyByZWYgZ3VscGZpbGUgZGlyIChwcm9qZWN0IHJvb3QpXG5cdGxldCBwX3Jvb3QgPSBwYXRoLmRpcm5hbWUobW9kdWxlLnBhcmVudC5wYXJlbnQuZmlsZW5hbWUpO1xuXG5cdC8vIHBsdWdpbiBvcHRpb25zXG5cdGxldCBoX3BsdWdpbl9vcHRpb25zID0gaF9jb25maWcucGx1Z2lucyB8fCB7fTtcblxuXHQvLyByZWYgcGx1Z2luIHJlZ2V4XG5cdGxldCByX3BsdWdpbnMgPSBoX3BsdWdpbl9vcHRpb25zLnBhdHRlcm4gfHwgUl9QTFVHSU5TO1xuXG5cdC8vIHJlZiBwbHVnaW4gdHJhbnNmb3JtXG5cdGxldCBmX3RyYW5zZm9ybSA9IGhfcGx1Z2luX29wdGlvbnMudHJhbnNmb3JtIHx8IEZfVFJBTlNGT1JNO1xuXG5cblx0Ly8gcHJlcCBwbHVnaW5zIGhhc2hcblx0bGV0IGhfcGx1Z2lucztcblxuXHQvLyBwcmVwIGRldkRlcGVuZGVuY2llcyBoYXNoXG5cdGxldCBoX2Rldl9kZXBlbmRlbmNpZXMgPSB7fTtcblxuXHQvLyBsb2FkIHBsdWdpbnNcblx0Y29uc3QgcGx1Z2lucyA9ICgpID0+IHtcblx0XHQvLyBub3QgeWV0IGNhY2hlZFxuXHRcdGlmKCFoX3BsdWdpbnMpIHtcblx0XHRcdC8vIG1ha2UgcGx1Z2lucyBoYXNoXG5cdFx0XHRoX3BsdWdpbnMgPSB7fTtcblxuXHRcdFx0Ly8gbG9hZCBtb2R1bGUncyBwYWNrYWdlLmpzb25cblx0XHRcdGhfZGV2X2RlcGVuZGVuY2llcyA9IHJlcXVpcmUocGF0aC5qb2luKHBfcm9vdCwgJ3BhY2thZ2UuanNvbicpKS5kZXZEZXBlbmRlbmNpZXM7XG5cblx0XHRcdC8vIGZldGNoIGRldiBkZXBlbmRlbmNpZXMgZnJvbSBwYWNrYWdlLmpzb25cblx0XHRcdE9iamVjdC5rZXlzKGhfZGV2X2RlcGVuZGVuY2llcylcblx0XHRcdFx0Ly8gZWFjaCBndWxwIHBsdWdpbiAob3Igd2hhdGV2ZXIgbWF0Y2hlcyB0aGUgcmVnZXgpXG5cdFx0XHRcdC5mb3JFYWNoKChzX2RlcCkgPT4ge1xuXG5cdFx0XHRcdFx0Ly8gZm91bmQgZ3VscCBwbHVnaW5cblx0XHRcdFx0XHRpZihyX3BsdWdpbnMudGVzdChzX2RlcCkpIHtcblxuXHRcdFx0XHRcdFx0Ly8gc2tpcCBsb2FkaW5nIHRoaXMgcGFja2FnZVxuXHRcdFx0XHRcdFx0aWYoJ2d1bHAtc29kYScgPT09IHNfZGVwKSByZXR1cm47XG5cblx0XHRcdFx0XHRcdC8vIG1ha2UgbnBtIHJlcXVpcmUgcGF0aCB0byBwbHVnaW5cblx0XHRcdFx0XHRcdGxldCBwX3BsdWdpbiA9IHBhdGguam9pbihwX3Jvb3QsICdub2RlX21vZHVsZXMnLCBzX2RlcCk7XG5cblx0XHRcdFx0XHRcdC8vIHRyYW5zZm9ybSBuYW1lIHRvIGtleSwgbG9hZCBwbHVnaW4gaW50byBoYXNoXG5cdFx0XHRcdFx0XHRoX3BsdWdpbnNbZl90cmFuc2Zvcm0oc19kZXApXSA9IHJlcXVpcmUocF9wbHVnaW4pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhfcGx1Z2lucztcblx0fTtcblxuXG5cdC8qKlxuXHQqIGxvYWQgcmVjaXBlczpcblx0KiovXG5cblx0Ly8gcmVmIHJlY2lwZSBkaXJcblx0bGV0IHNfcmVjaXBlX2RpciA9IGhfY29uZmlnLnJlY2lwZXMgfHwgU19SRUNJUEVfRElSO1xuXG5cdC8vIHJlZiByZWNpcGUgZGlyZWN0b3J5XG5cdGxldCBwX3JlY2lwZV9kaXIgPSBwYXRoLmpvaW4ocF9yb290LCBzX3JlY2lwZV9kaXIpO1xuXG5cblx0LyoqXG5cdCogbWFrZSB0YXNrczpcblx0KiovXG5cblx0Ly8gcHJlcCB0YXNrIGluZm8gaGFzaFxuXHRsZXQgaF90YXNrX2luZm8gPSB7fTtcblxuXHQvLyByZWYgZ2xvYmFsIGNvbmZpZ1xuXHRsZXQgaF9nbG9iYWxfY29uZmlnID0gaF9jb25maWcuY29uZmlnIHx8IHt9O1xuXG5cdC8vIHJlZiBkb21haW4gJiByYW5nZVxuXHRsZXQgaF9kb21haW4gPSBoX2NvbmZpZy5kb21haW4gfHwge307XG5cdGxldCBoX3JhbmdlID0gaF9jb25maWcucmFuZ2UgfHwge307XG5cblx0Ly8gcmVmIHNyYyBhbmQgZGVzdCByb290XG5cdGxldCBzX3NyY19kaXIgPSBoX2NvbmZpZy5zcmMgfHwgU19TUkNfRElSO1xuXHRsZXQgc19kZXN0X2RpciA9IGhfY29uZmlnLmRlc3QgfHwgU19ERVNUX0RJUjtcblxuXHQvLyByZWYgb3B0aW9uc1xuXHRsZXQgaF9vcHRpb25zID0gaF9jb25maWcub3B0aW9ucyB8fCB7fTtcblxuXHQvLyBwcmVwIHRhc2sgbGlzdHMgaGFzaFxuXHRsZXQgaF90YXNrX2xpc3RzID0ge307XG5cblx0Ly8gdHJhY2sgZW1wdHkgdGFzayBkZXBlbmRlbmNpZXNcblx0bGV0IGhfZW1wdHlfdGFza3MgPSB7fTtcblxuXG5cdC8vIGVhY2ggZGlyIHRhcmdldCBpbiBkb21haW5cblx0Zm9yKGxldCBzX2RpciBpbiBoX2RvbWFpbikge1xuXG5cdFx0Ly8gcmVmIHJhbmdlXG5cdFx0bGV0IGFfcmFuZ2UgPSBoX2RvbWFpbltzX2Rpcl07XG5cblx0XHQvLyBhc3N1cmUgcmFuZ2UgaXMgYXJyYXlcblx0XHRpZignc3RyaW5nJyA9PT0gdHlwZW9mIGFfcmFuZ2UpIGFfcmFuZ2UgPSBbYV9yYW5nZV07XG5cblx0XHQvLyBwcmVwIGxpc3Qgb2YgZGVmYXVsdHMgZm9yIGRpcmVjdG9yeSB0YXNrIGxpc3Rcblx0XHRsZXQgYV9kZWZhdWx0cyA9IFtdO1xuXG5cdFx0Ly8gcHJlcCBncm91cHMgaGFzaCBmb3IgZ291cnBpbmcgc2FtZSBuYW1lcyBvZiBkaWZmZXJlbnQgb3V0cHV0c1xuXHRcdGxldCBoX2dyb3VwcyA9IHt9O1xuXG5cdFx0Ly8gZWFjaCByYW5nZSBpbiBhcnJheVxuXHRcdGFfcmFuZ2UuZm9yRWFjaCgoc19yYW5nZV90YXJnZXQpID0+IHtcblxuXHRcdFx0Ly8gZXh0cmFjdCBsYWJlbHMgZnJvbSByYW5nZSB0YXJnZXRcblx0XHRcdGxldCBbc19yYW5nZSwgc190YXNrX2Rlc3RfZGlyXSA9IHNfcmFuZ2VfdGFyZ2V0LnNwbGl0KC9cXHMqWzpcXHNdXFxzKi8pO1xuXG5cdFx0XHQvLyByZWYgcmVjaXBlIGxpc3Rcblx0XHRcdGxldCBhX3JlY2lwZV9saXN0ID0gaF9yYW5nZVtzX3JhbmdlXTtcblxuXHRcdFx0Ly8gY3JlYXRlIHNyYyBhbmQgZGVzdCBwYXRoc1xuXHRcdFx0bGV0IHBfc3JjID0gcGF0aC5qb2luKHNfc3JjX2Rpciwgc19kaXIpO1xuXHRcdFx0bGV0IHBfZGVzdCA9IHBhdGguam9pbihzX3Rhc2tfZGVzdF9kaXIgfHwgc19kZXN0X2Rpciwgc19kaXIpO1xuXG5cdFx0XHQvLyBlYWNoIHJlY2lwZVxuXHRcdFx0YV9yZWNpcGVfbGlzdC5mb3JFYWNoKChzX3JlY2lwZV90YXJnZXQsIGlfcmVjaXBlKSA9PiB7XG5cblx0XHRcdFx0Ly8gZXh0cmFjdCByZWNpcGUgbmFtZSBhbmQgaXRzIGRlcGVuZGVuY2llcyBmcm9tIHRhcmdldCBzdHJpbmdcblx0XHRcdFx0bGV0IFtzX3JlY2lwZSwgLi4uYV9kZXBzXSA9IHNfcmVjaXBlX3RhcmdldC5zcGxpdCgvXFxzKls6XFxzXVxccyovZyk7XG5cblx0XHRcdFx0Ly8gdGFzayBpcyBlbXB0eSAobm8gcmVjaXBlKVxuXHRcdFx0XHRsZXQgYl9lbXB0eV90YXNrID0gJ1snID09PSBzX3JlY2lwZVswXTtcblx0XHRcdFx0aWYoYl9lbXB0eV90YXNrKSB7XG5cdFx0XHRcdFx0c19yZWNpcGUgPSBzX3JlY2lwZS5zbGljZSgxLCAtMSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBtYWtlIHRhc2sgbmFtZVxuXHRcdFx0XHRsZXQgc190YXNrID0gYCR7c19yZWNpcGV9LSR7c19kaXJ9YDtcblxuXHRcdFx0XHQvLyByZWYgdGFzayBuYW1lIG1vZFxuXHRcdFx0XHRsZXQgc190YXNrX21vZCA9ICcnO1xuXG5cdFx0XHRcdC8vIHRoZXJlIGFyZSBtdWx0aXBsZSByYW5nZXNcblx0XHRcdFx0aWYoYV9yYW5nZS5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0Ly9cdHNoaWZ0IHRhc2sgbmFtZSB0byBncm91cCBuYW1lXG5cdFx0XHRcdFx0bGV0IHNfZ3JvdXAgPSBzX3Rhc2s7XG5cblx0XHRcdFx0XHQvLyByZWYgZ3JvdXBcblx0XHRcdFx0XHRsZXQgYV9ncm91cCA9IGhfZ3JvdXBzW3NfZ3JvdXBdIHx8IChoX2dyb3Vwc1tzX2dyb3VwXSA9IFtdKTtcblxuXHRcdFx0XHRcdC8vIGNyZWF0ZSBkaXN0aW5ndWlzaGVkIHRhc2sgbmFtZVxuXHRcdFx0XHRcdHNfdGFza19tb2QgPSBgLSR7c19yYW5nZX1gO1xuXHRcdFx0XHRcdHNfdGFzayArPSBzX3Rhc2tfbW9kO1xuXG5cdFx0XHRcdFx0Ly8gYWRkIHRoaXMgdGFzayBuYW1lIHRvIHRoZSBncm91cFxuXHRcdFx0XHRcdGFfZ3JvdXAucHVzaChzX3Rhc2spO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdGhpcyByZWNpcGUgaXMgMHRoIHRhcmdldCBpbiBkb21haW4sIGFkZCBpdCB0byB0aGUgZGVmYXVsdHNcblx0XHRcdFx0aWYoMCA9PT0gaV9yZWNpcGUpIHtcblx0XHRcdFx0XHRhX2RlZmF1bHRzLnB1c2goc190YXNrKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG1ha2UgZHBlcyBmb3IgdGhpcyB0YXNrXG5cdFx0XHRcdGxldCBhX3Rhc2tfZGVwcyA9IGFfZGVwcy5tYXAoc19kZXAgPT4gYCR7c19kZXB9LSR7c19kaXJ9YCtzX3Rhc2tfbW9kKTtcblx0XHRcdFx0YV90YXNrX2RlcHMuZm9yRWFjaCgoc19vdGhlcl90YXNrLCBpX290aGVyX3Rhc2spID0+IHtcblx0XHRcdFx0XHQvLyByZWYgZW1wdHkgdGFzaydzIGRlcGVuZGVuY2llcyBpZiBleGlzdHNcblx0XHRcdFx0XHRsZXQgYV9lbXB0eV9kZXBzID0gaF9lbXB0eV90YXNrc1tzX290aGVyX3Rhc2tdO1xuXG5cdFx0XHRcdFx0Ly8gaXQgYWN0dWFsbHkgaXMgYW4gZW1wdHkgdGFza1xuXHRcdFx0XHRcdGlmKGFfZW1wdHlfZGVwcykge1xuXHRcdFx0XHRcdFx0Ly8gYXBwZW5kIGFsbCBpdHMgZGVwZW5kZW5jaWVzIHRvIHRoaXMgbGlzdFxuXHRcdFx0XHRcdFx0YV90YXNrX2RlcHMucHVzaCguLi5hX2VtcHR5X2RlcHMpO1xuXG5cdFx0XHRcdFx0XHQvLyByZW1vdmUgZGVwZW5kZW5jeSB0byBlbXB0eSB0YXNrXG5cdFx0XHRcdFx0XHRhX3Rhc2tfZGVwcy5zcGxpY2UoaV9vdGhlcl90YXNrLCAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIG1ha2Ugb3B0aW9ucyBoYXNoIGZvciB0aGlzIHRhc2ssIHNhdmUgdG8gcGVyc2lzdGVudCBvcHRpb25zIGhhc2hcblx0XHRcdFx0bGV0IGhfdGFza19vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSxcblx0XHRcdFx0XHRoX29wdGlvbnNbJyonXSB8fCB7fSxcblx0XHRcdFx0XHRoX29wdGlvbnNbc19yZWNpcGVdIHx8IHt9LFxuXHRcdFx0XHRcdGhfb3B0aW9uc1tzX3Rhc2tdIHx8IHt9KTtcblxuXHRcdFx0XHQvLyBtYWtlIHNyYyBnbG9iXG5cdFx0XHRcdGxldCBwX3Rhc2tfc3JjID0gcGF0aC5qb2luKHBfc3JjLCBoX3Rhc2tfb3B0aW9ucy5zcmMgfHwgJycpO1xuXG5cdFx0XHRcdC8vIHNhdmUgdG8gdGFzayBpbmZvXG5cdFx0XHRcdGhfdGFza19pbmZvW3NfdGFza10gPSB7XG5cdFx0XHRcdFx0c3JjOiBwX3Rhc2tfc3JjLFxuXHRcdFx0XHRcdGRlc3Q6IHBfZGVzdCxcblx0XHRcdFx0XHRkZXBzOiBhX3Rhc2tfZGVwcyxcblx0XHRcdFx0XHRvcHRpb25zOiBoX3Rhc2tfb3B0aW9ucyxcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBkZXBlbmRlbmNpZXMtb25seSByZWNpcGU7IG1ha2UgdGFza1xuXHRcdFx0XHRpZihiX2VtcHR5X3Rhc2spIHtcblx0XHRcdFx0XHRoX2VtcHR5X3Rhc2tzW3NfdGFza10gPSBhX3Rhc2tfZGVwcztcblx0XHRcdFx0XHRyZXR1cm4gZ3VscC50YXNrKHNfdGFzaywgYV90YXNrX2RlcHMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbWFrZSB0YXNrLCBzdWNoIHRoYXQgb25seSBvbmNlIGl0IGlzIGNhbGxlZCBkbyB3ZSBtYWtlIG1vdmVzXG5cdFx0XHRcdGd1bHAudGFzayhzX3Rhc2ssIGFfdGFza19kZXBzLCAoZl9kb25lX3Rhc2spID0+IHtcblxuXHRcdFx0XHRcdC8vIG9ubHkgb25jZSB0aGlzIHRhc2sgaXMgY2FsbGVkLCBsb2FkIHRoZSByZWNpcGUgc2NyaXB0XG5cdFx0XHRcdFx0bGV0IGZfcmVjaXBlO1xuXHRcdFx0XHRcdHRyeSB7IGZfcmVjaXBlID0gcmVxdWlyZShwYXRoLmpvaW4ocF9yZWNpcGVfZGlyLCBzX3JlY2lwZSkrJy5qcycpOyB9XG5cdFx0XHRcdFx0Y2F0Y2goZV9sb2FkX3JlY2lwZSkge1xuXHRcdFx0XHRcdFx0aWYoJ01PRFVMRV9OT1RfRk9VTkQnID09PSBlX2xvYWRfcmVjaXBlLmNvZGUpIHtcblx0XHRcdFx0XHRcdFx0ZXJyb3IoYG5vIHN1Y2ggcmVjaXBlIFwiJHtzX3JlY2lwZX1cIiBmb3VuZCBpbiByZWNpcGUgZGlyZWN0b3J5IFwiJHtzX3JlY2lwZV9kaXJ9XCIgeyR7cGF0aC5qb2luKHBfcmVjaXBlX2Rpciwgc19yZWNpcGUpKycuanMnfX1gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRlcnJvcihgc2NyaXB0IHJlY2lwZSBcIiR7c19yZWNpcGV9XCIgaGFzIGEgc3ludGF4L3J1bnRpbWUgZXJyb3I6YCwgZV9sb2FkX3JlY2lwZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gcmVjaXBlIGlzIGtpbmQgZW5vdWdoIHRvIHJlcXVpcmUgcGx1Z2luc1xuXHRcdFx0XHRcdGlmKGZfcmVjaXBlLnBsdWdpbnMpIHtcblx0XHRcdFx0XHRcdC8vIG1ha2UgcGx1Z2lucyBoYXNoXG5cdFx0XHRcdFx0XHRwbHVnaW5zKCk7XG5cblx0XHRcdFx0XHRcdC8vIGNoZWNrIGVhY2ggcGx1Z2luXG5cdFx0XHRcdFx0XHRmX3JlY2lwZS5wbHVnaW5zLmZvckVhY2goKHNfcGx1Z2luKSA9PiB7XG5cdFx0XHRcdFx0XHRcdC8vIHBsdWdpbiBpcyBtaXNzaW5nIGZyb20gZGV2RGVwZW5kZW5jaWVzXG5cdFx0XHRcdFx0XHRcdGlmKCFoX2Rldl9kZXBlbmRlbmNpZXNbc19wbHVnaW5dKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcihgXFxuV0FSTklORzogdGhlIFwiJHtzX3JlY2lwZX1cIiByZWNpcGUgd2FzIGtpbmQgZW5vdWdoIHRvIGRlY2xhcmUgdGhhdCBpdCByZXF1aXJlcyB0aGUgXCIke3NfcGx1Z2lufVwiIHBsdWdpbiB0byBmdW5jdGlvbiBwcm9wZXJseTsgeW91IGN1cnJlbnRseSBkbyBOT1QgaGF2ZSBzdWNoIGEgcGx1Z2luIGxpc3RlZCBpbiB5b3VyIHBhY2thZ2UuanNvbidzIGRldkRlcGVuZGVuY2llcy4gVGhpcyBjb3VsZCBiZSB0aGUgcmVhc29uIGZvciBhbnkgZXJyb3JzIHlvdSBhcmUgZ2V0dGluZ1xcbmApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBmb3J3YXJkIGNvbnRyb2wgdG8gcmVjaXBlXG5cdFx0XHRcdFx0bGV0IHpfcmV0dXJuID0gZl9yZWNpcGUuYXBwbHkoe1xuXHRcdFx0XHRcdFx0Ly8gc291cmNlIGRpcmVjdG9yeVxuXHRcdFx0XHRcdFx0c3JjX2RpcjogcF9zcmMsXG5cblx0XHRcdFx0XHRcdC8vIHNldCBzdWIgZGlyZWN0b3J5IGRlc3RpbmF0aW9uIHdpdGhpbiBkZXN0aW5hdGlvbiBkaXJcblx0XHRcdFx0XHRcdHN1Yl9kZXN0OiAoc19zdWJfZGlyKSA9PiBwYXRoLmpvaW4oc190YXNrX2Rlc3RfZGlyIHx8IHNfZGVzdF9kaXIsIHNfc3ViX2RpciksXG5cblx0XHRcdFx0XHRcdC8vIGNvbmZpZyBzZXR0aW5nc1xuXHRcdFx0XHRcdFx0Y29uZmlnOiBoX2dsb2JhbF9jb25maWcsXG5cblx0XHRcdFx0XHRcdC8vIHRhc2sgbmFtZVxuXHRcdFx0XHRcdFx0dGFzazogc190YXNrLFxuXG5cdFx0XHRcdFx0XHQvLyB0YXNrIGRlcGVuZGVuY2llc1xuXHRcdFx0XHRcdFx0ZGVwczogYV90YXNrX2RlcHMsXG5cblx0XHRcdFx0XHRcdC8vIHRhc2sgb3B0aW9uc1xuXHRcdFx0XHRcdFx0b3B0aW9uczogaF90YXNrX29wdGlvbnMsXG5cblx0XHRcdFx0XHRcdC8vIGFsbG93IHJlY2lwZSB0byByZWYgb3RoZXIgZGVwZW5kZW5jaWVzXG5cdFx0XHRcdFx0XHRvdGhlcjogKHNfZGVwKSA9PiBgJHtzX2RlcH0tJHtzX2Rpcn1gK3NfdGFza19tb2QsXG5cblx0XHRcdFx0XHRcdC8vIGFsbG93IHJlY2lwZSB0byByZWYgb3RoZXIgc3JjXG5cdFx0XHRcdFx0XHRmcmllbmQ6IChzX2RlcCkgPT4gaF90YXNrX2luZm9bc19kZXBdLFxuXHRcdFx0XHRcdH0sIFtndWxwLCBwbHVnaW5zKCksIHBfdGFza19zcmMsIHBfZGVzdCwgZl9kb25lX3Rhc2tdKTtcblxuXHRcdFx0XHRcdC8vIHJlY2lwZSBkaWQgbm90IGFzayBmb3IgYXN5bmMgY2FsbGJhY2tcblx0XHRcdFx0XHRpZighel9yZXR1cm4gJiYgZl9yZWNpcGUubGVuZ3RoIDw9IDQpIHtcblx0XHRcdFx0XHRcdC8vIGNhbGxiYWNrIG9uIG5leHQgZXZlbnQgbG9vcCBwYXNzXG5cdFx0XHRcdFx0XHRzZXRJbW1lZGlhdGUoKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRmX2RvbmVfdGFzaygpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gcmV0dXJuIHdoYXRldmVyIHJlY2lwZSBkaWRcblx0XHRcdFx0XHRyZXR1cm4gel9yZXR1cm47XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIHJlZiBjb3JyZXNwb25kaW5nIHRhc2sgbGlzdFxuXHRcdFx0XHRsZXQgYV90YXNrX2xpc3QgPSBoX3Rhc2tfbGlzdHNbc19yZWNpcGVdO1xuXG5cdFx0XHRcdC8vIGNvcnJlc3BvbmRpbmcgdGFzayBsaXN0IGRvZXMgbm90IHlldCBleGlzdDsgY3JlYXRlIGl0XG5cdFx0XHRcdGlmKCFhX3Rhc2tfbGlzdCkgYV90YXNrX2xpc3QgPSBoX3Rhc2tfbGlzdHNbc19yZWNpcGVdID0gW107XG5cblx0XHRcdFx0Ly8gYXBwZW5kIHRhc2sgbmFtZSB0byBpdHMgY29ycmVzcG9uZGluZyB0YXNrIGxpc3Rcblx0XHRcdFx0YV90YXNrX2xpc3QucHVzaChzX3Rhc2spO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHQvLyB0aGVyZSBhcmUgbXVsdGlwbGUgb3V0cHV0c1xuXHRcdGZvcihsZXQgc19ncm91cF9uYW1lIGluIGhfZ3JvdXBzKSB7XG5cdFx0XHQvLyBjcmVhdGUgdGFzayBncm91cFxuXHRcdFx0Z3VscC50YXNrKHNfZ3JvdXBfbmFtZSwgaF9ncm91cHNbc19ncm91cF9uYW1lXSk7XG5cdFx0fVxuXG5cdFx0Ly8gY3JlYXRlIGRlZmF1bHRzIHRhc2sgZ3JvdXBcblx0XHRndWxwLnRhc2soc19kaXIsIGFfZGVmYXVsdHMpO1xuXHR9XG5cblxuXHQvKipcblx0KiBhcHBlbmQgc2hvcnRjdXQgdGFza3M6XG5cdCoqL1xuXG5cdC8vIGJ1aWxkIGRlZmF1bHQgdGFza3MgZm9yIGVhY2ggdHlwZVxuXHRmb3IobGV0IHNfZ2VuZXJhbF90YXNrIGluIGhfdGFza19saXN0cykge1xuXHRcdGxldCBhX2RlcHMgPSBoX3Rhc2tfbGlzdHNbc19nZW5lcmFsX3Rhc2tdO1xuXG5cdFx0Ly8gbGluayBkZXBlbmRlbmNpZXMgdG8gdHJpZ2dlciB0aG9zZSB0YXNrc1xuXHRcdGd1bHAudGFzayhzX2dlbmVyYWxfdGFzaywgYV9kZXBzKTtcblx0fVxuXG5cblx0Ly8gcmVmIGFsaWFzZXMgZnJvbSBjb25maWdcblx0bGV0IGhfYWxpYXNlcyA9IGhfY29uZmlnLmFsaWFzZXM7XG5cblx0Ly8gYWRkIGFsaWFzZXNcblx0T2JqZWN0LmtleXMoaF9hbGlhc2VzIHx8IHt9KS5mb3JFYWNoKChzX2FsaWFzKSA9PiB7XG5cdFx0bGV0IGFfdGFza3MgPSBoX2FsaWFzZXNbc19hbGlhc107XG5cblx0XHQvLyByZWdpc3RlciBhbGlhcyB0YXNrXG5cdFx0Z3VscC50YXNrKHNfYWxpYXMsIGFfdGFza3MpO1xuXHR9KTtcblxuXG5cdC8vIHJlZ2lzdGVyIGRlZmF1bHQgdGFza1xuXHRndWxwLnRhc2soJ2RlZmF1bHQnLCBPYmplY3Qua2V5cyhoX2RvbWFpbikpO1xufTtcbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
