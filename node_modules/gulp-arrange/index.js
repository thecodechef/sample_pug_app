"use strict";

var through = require("through2");
var Minimatch = require("minimatch").Minimatch;

var patterns;
var options;
var usesRegex;
var fileAttribute;
var matchers;

class Matcher {
  constructor(object) {
    if (object instanceof Minimatch) {
      this.test = object.match.bind(object);
    }
    // object instanceof RegExp
    else {
      this.test = object.test.bind(object);
    }
  }

  match(input) {
    return this.test(input);
  }
}

function getSortIndicationNumber(fileA, fileB) {
  var indexA = getMatchingMatcherIndex(fileA[fileAttribute]);
  var indexB = getMatchingMatcherIndex(fileB[fileAttribute]);
  var returnValue = 0;
  if ((indexA !== -1) && (indexB !== -1)) {
    returnValue = indexA - indexB;
  } else if(indexA === -1) {
    returnValue = -1;
  } else if(indexB === -1) {
    returnValue = 1;
  }
  return returnValue;
}

function getMatchingMatcherIndex(input) {
  var returnValue = -1;
  matchers.some(function (matcher, index) {
    if (matcher.match(input)) {
      returnValue = index;
      return true;
    }
    return false;
  });
  return returnValue;
}

module.exports = function (params) {
  patterns = params.patterns;
  options = params.options;
  usesRegex = !!params.usesRegex;
  fileAttribute = params.fileAttribute || "relative";
  matchers = patterns.map(function (pattern) {
    return new Matcher(new((usesRegex ? RegExp : Minimatch).bind(null, pattern, options)));
  });

  var files = [];
  return through.obj(function (file, encoding, callback) {
    files.push(file);
    callback();
  }, function (callback) {
    var self = this;
    files.sort(function (fileA, fileB) {
      return getSortIndicationNumber(fileA, fileB);
    });
    files.forEach(function (file) {
      self.push(file);
    });
    callback();
  });
};