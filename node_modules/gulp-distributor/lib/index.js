/**

The MIT License (MIT)

Copyright (c) 2013-2014 Michael Herndon http://dev.michaelherndon.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/


var through = require('through2');
var gutil = require('gulp-util');
    fs = require("fs"),
    Path = require("path");
var PluginError = gutil.PluginError;

// Consts
const PLUGIN_NAME = 'gulp-distributor';

var defaults = {
    src: "src/",
    dist: {
        src: "dist",
        //es6: "$src/es6/lib",
        amd: "$src/amd/lib",
        browser: "$src/browser/lib",
        commonjs: "lib"
       
    },
    templates: {
        src: __dirname + "/templates",
        //es6: "$src/es6.tpl",
        amd: "$src/amd.tpl",
        browser: "$src/browser.tpl",
        commonjs: "$src/lib.tpl"
    },
    newLine: {
        amd: "\n\t",
        browser: "\n\t"
    },
    templateEngine: function() {
        return require("lodash").template;
    },
    distro: ["all"],
    namespace: null,
    exports: null,
    files: null,
    license: null,
    data: null,
    pattern: "$file"
};


var replaceVars = function(str, vars) {
   for(var p in vars)
   {
      str = str.replace("$" + p, vars[p]);
   }

   return str;
};

var camelize = function(old) {
    var name = "",
        upper = false;
    for(var c1 in old) {
            var c = old[c1];
            if(c === '-' || c === '_') {
                upper = true;
                continue;
            }

            if(upper) {
                name += c.toString().toUpperCase();
                upper = false;
                continue;
            }

            name += c;
        }
    return name;
}


if(!Object.assign) {

  /**
   * Assigns the values of the source(s) to the target object.
   * 
   * @example
   *    var target = {property: "value"},
   *        targetRef = Object.assign(target, {newProperty: "value2"});
   *
   *      console.log(targetRef); // {property: "value", {newProperty: "value2"}};
   *
   *      // multiple sources
   *      //
   *      // [{}, {}].reduce(Object.assign, target);
   *      // Object.assign(target, {}, {}, {});
   *
   * @param {Object} target The object that will values replaced. 
   * @param {Object} source* The source of values that will replace the values in the the target.
   * @return {Object} The target object after value assignment has occurred.
   */
    Object.assign = function( target, source ) {
    /// <summary> Assigns the values of the source(s) to the target object. </summary>
    /// <param name="target" type="object">The object that will have values replaced. </param>
    /// <source name="source" type="object">The source of values that will replace the values in the target. </param>
    /// <return type="object">Returns the target object.</return>

        var to, sourceList = [], i = 1, l = 0;

        to = Object( target );
      
        if( arguments.length > 1 ) {
            l = arguments.length;
            sourceList = new Array( l - 1 );

            for(; i < l; i++)
                sourceList[i - 1] = arguments[i];
        }
    
        l = sourceList.length;
    
        for(i = 0; i < l; i++) {
            /* jshint loopfunc: true */
            (function(i){
                var from = Object(sourceList[i]),
                keysArray = Object.getOwnPropertyNames(from),
                len = keysArray.length,
                nextIndex = 0;

                while(nextIndex < len) {
                    var nextKey = keysArray[nextIndex.toString()];
                    var desc = from[nextKey];

                    if(desc !== undefined && desc)
                    {
                        to[nextKey] = desc;
                    }

                    nextIndex++;
                } 

            })(i);
        }

        return to;
    };
}


function getTemplatesFiles(o) {
    if(!o)
        throw new Error("options is null");
  
    var templates = o.templates;

    if(!templates)
        throw new Error("templates is null");

    var src = templates.src;
    var result = {};
    for(var p in templates)
    {
        (function(key){
            if(key === "src")
                return;

            var value = templates[key];
    

            if(value === undefined || value === null || value === false || value.trim() === "")
                return;

            result[key] = replaceVars(value, {src: src});
        })(p);
        
    }

    return result;
};

function parsePath(path) {
    var ext = Path.extname(path);
    return {
        directory: Path.dirname(path),
        name: Path.basename(path, ext),
        ext: ext
    };
};



  
// Plugin level function(dealing with files)
function distribute(options) {
    var o = {};
    o = Object.assign(o, defaults, options || {}); 
   

    var templatePaths = getTemplatesFiles(o);
    var templates = {};
    
    for(var key in templatePaths) {
       
        (function(key){
            if(!Array.isArray(o.distro))
                o.distro = [o.distro];

            if(o.distro.indexOf("all") > -1 || o.distro.indexOf(key) > -1) {
                
                var tp = templatePaths[key]
                if(!fs.existsSync(tp))
                {
                    console.warn("could not find " + key +" template, " + tp);
                    return;
                }

                templates[key] = (fs.readFileSync(tp));
            }

        })(key);
    }



    var d = Object.assign({}, o.data);

    if(o.license) {
        d.license = fs.readFileSync(o.license).toString();
        d.namespace = "" + o.namespace;
        d.exports = "";
        d.deps = "";
        d.content = "";
        d.require = "";
    }

  
    var template = o.templateEngine();

    for(var f in o.files)
    {

        var matchOn = o.pattern.replace("$file", f);
        var file =  ("$src" + matchOn + ".js").replace("$src", f.src || o.src);

        if(fs.existsSync(file))
        {
            var relative = "";
            var path = matchOn;
            if(matchOn.indexOf("/") > -1)
            {
                var slashIndex = matchOn.lastIndexOf("/");
                relative = matchOn.substring(0, slashIndex);
                path = matchOn.substring(slashIndex + 1);
            }
            fileInfo = o.files[f];
            fileInfo.file = file;
            fileInfo.fileName = path;
            fileInfo.relative = relative;
            fileInfo.isLocal = true;
            o.files[f] = fileInfo;
        }
    }

    
    var stream = through.obj(function(file, enc, callback) {

        if (file.isNull()) {
          this.push(file);
          return callback();
        }

        if (file.isStream()) {
            this.emit('error', new gutil.PluginError('gulp-template', 'Streaming not supported'));
        }

        var path = parsePath(file.relative);
        var exports = o.exports || [];
        var namespace = o.namespace;
        var deps = o.deps || [];
        var data = {};
        var relative = path.directory ;
        
        data = Object.assign(data, d);
        data.exports  = data.exports || "";
        data.deps = data.deps || "";

        var distro = Object.assign({}, o.dist);
        var name = path.name, upper = false;
        
        if(o.files)
        {
            var fileInfo = null;
            for(var f in o.files)
            {
                var fi = o.files[f];
                
                if(fi.fileName && fi.fileName.toLowerCase() === path.name.toLowerCase())
                {
                    name = f;
                    fileInfo = fi;
                    break;
                }
            }

            if(fileInfo)
            {
                exports = exports.concat(fileInfo.exports || []);
                namespace = fileInfo.namespace || namespace;
                deps = deps.concat(fileInfo.deps || []);
                if(fileInfo.dist)
                    Object.assign(distro, o.dist);

                relative = fileInfo.relative;
            }
        }

        var old = name;
        name = camelize(old);

        data.browserExports = "";
        if(exports.length > 0)
        {
            if(exports.length === 1 && exports[0] === 'self') {

               
                    data.exports += "exports = " + name + ";\n";
                    //data.exports += "if(typeof module !== 'undefined') { \n\t module.exports = exports;\n }";
                    
                    data.browserExports += "exports."+ name + " = " + name + ";\n\t";
                
            } else {
                exports.forEach(function(exported) {
                   
                    data.exports += "exports." + exported + " = " + exported + ";\n\t";
                    data.browserExports += "exports."+ exported + " = " + exported + ";\n\t";
                });
            }
        }

        data.deps = [];
         data.require = data.require || "";
        if(deps.length > 0)
        {

            var assign = "";
            var count = 0;
            var normalizedDebs = [];
            deps.forEach(function(dep) {

                if(o.files && o.files[dep]) {
                    var info = o.files[dep];
                    var depName = info.isLocal ? ("./" + dep) : dep;
                    var requirePath = info.require || depName;
                    

                    
                    normalizedDebs.push(depName);

                    if(info.exports && info.exports.length > 0) {
                        var $v = "d" + count;
                        data.require += "var " + $v + " = require(\"" + requirePath +"\"),\n\t\t";
                        var vars = [];
                        info.exports.forEach(function(exported){
                            if(exported === "self")
                                vars.push(camelize(dep) + " = " + $v);                            
                            else 
                                vars.push(exported +" = " + $v + "." + exported); 
                        });

                        data.require += vars.join(",\n\t\t") + ";";
                        count++;
                        return;
                    } 
                } else {
                    normalizedDebs.push(dep);
                }


                data.require += "var " + dep + " = require("+ requirePath +");";
                count++;
           });

            data.deps = normalizedDebs

        }

        data.name = old;
        data.namespace = namespace;
        if (file.isBuffer()) {

            data.contents =  file.contents.toString();
            var dSrc = o.dist.src;

            for(var k in templates) {
               (function(key) {
                  
                    var tpl = templates[key];
                    var dist = distro[key].replace("$src", dSrc) + relative;
                    var dest = dist +"/" +path.name.replace("-src", "") + ".js";
                    var finalContent = template(tpl.toString(), data);

                    

                    var write = function() {
                        fs.writeFile(dest, finalContent, {flag: 'w+'}, function (err) {
                          if (err) 
                            throw err;
                         
                        });
                    }


                    if(!fs.existsSync(dist))
                    {
                        var mkdir = require("mkdirp");
                        mkdir(dist, function (err) {
                            if (err) 
                                throw err
                            else 
                                write();
                        });
                    } else {
                        write();
                    }
                 
                    
               })(k)
                
            }
        }

        this.push(file);
        return callback();
    });

 
    return stream;
};


module.exports = distribute;