
var globReplace = require("../"),
    should      = require("should"),
    src         = require("vinyl-fs").src,
    through2    = require("through2"),
    PluginError = require("gulp-util").PluginError,
    _           = require("lodash"),
    crypto      = require("crypto"),
    path        = require("path"),
    fs          = require("fs")
;

function md5(cb) {
    var md5 = crypto.createHash('md5'),
        buffer = [];
    return through2.obj(function (file, enc, done) {
        buffer.push(file);
        if(!file.isNull()) {
            md5.update(file.contents);
        }
        done();
    }, function (done) {
        if(typeof cb === "function") {
            cb(md5.digest('hex').substr(0, 8));
        }
        buffer.forEach(function (file) {
            this.push(file);
        }.bind(this));
        done();
    });
}

describe("globReplace()", function() {

    it("should throw an error for no glob provided", function(done) {
        try {
            globReplace();
        } catch(err) {
            err.should.be.an.instanceOf(PluginError);
            done();
        }
    });

    it("should throw an error for non-string globs", function(done) {
        try {
            globReplace([{}])
        } catch(err) {
            err.should.be.an.instanceOf(PluginError);
            done();
        }
    });

    it("should pass through nothing but original stream if glob doesn't match", function(done) {
        var hash1,
            hash2;

        src("./test/fixtures/src/**")
            .pipe(md5(function(hash) {hash1 = hash;}))
            .pipe(globReplace("./nonExistantFile.txt"))
            .pipe(md5(function(hash) {hash2 = hash;}))
            .on("finish", function() {
                hash1.should.be.eql(hash2);
                done();
            });

    });

    it("should overwrite files that paths match from the glob base onward", function(done) {
        var files = {};
        src("./test/fixtures/src/**")
            .pipe(globReplace("./test/fixtures/extended/**"))
            .pipe(through2.obj(function(file, enc, next) {
                files[path.basename(file.path)] = file;
                next();
            }))
            .on("finish", function() {
                files.should.have.properties([
                    "src",
                    "dir",
                    "file1.txt",
                    "file2.txt",
                    "file4.json",
                    "needle.png"
                ]);
                _.keys(files).should.have.length(7);
                files["file1.txt"].contents.should.be.eql(fs.readFileSync("./test/fixtures/extended/file1.txt"));
                files["file2.txt"].contents.should.be.eql(fs.readFileSync("./test/fixtures/src/file2.txt"));
                done();
            })
    });

    it("should include all files from extended folder with emitAll option", function(done) {
        var files = {};
        src("./test/fixtures/src/**")
            .pipe(globReplace("./test/fixtures/extended/**", {emitAll: true}))
            .pipe(through2.obj(function(file, enc, next) {
                files[path.basename(file.path)] = file;
                next();
            }))
            .on("finish", function() {
                files.should.have.properties([
                    "src",
                    "dir",
                    "dir2",
                    "file1.txt",
                    "file2.txt",
                    "file3.txt",
                    "file4.json",
                    "file5.txt",
                    "file6.txt",
                    "file7.txt",
                    "needle.png"
                ])
            });
    });

});